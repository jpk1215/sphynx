<html>
  <head>
    <script src="http://threejs.org/build/three.min.js"></script>
  </head>
  <body></body>
  <script type="text/javascript">THREE.OrbitControls = function ( object, domElement ) {

  this.object = object;
  this.domElement = ( domElement !== undefined ) ? domElement : document;


  this.enabled = true;

 
  this.target = new THREE.Vector3();
 
  this.center = this.target;

 
  this.noZoom = false;
  this.zoomSpeed = 1.0;

  this.minDistance = 0;
  this.maxDistance = Infinity;


  this.noRotate = false;
  this.rotateSpeed = 1.0;


  this.noPan = false;
  this.keyPanSpeed = 7.0; 

  
  this.autoRotate = false;
  this.autoRotateSpeed = 2.0; 
  
  this.minPolarAngle = 0; 
  this.maxPolarAngle = Math.PI; 

  
  this.noKeys = false;

  this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };


  var scope = this;

  var EPS = 0.000001;

  var rotateStart = new THREE.Vector2();
  var rotateEnd = new THREE.Vector2();
  var rotateDelta = new THREE.Vector2();

  var panStart = new THREE.Vector2();
  var panEnd = new THREE.Vector2();
  var panDelta = new THREE.Vector2();

  var dollyStart = new THREE.Vector2();
  var dollyEnd = new THREE.Vector2();
  var dollyDelta = new THREE.Vector2();

  var phiDelta = 0;
  var thetaDelta = 0;
  var scale = 1;
  var pan = new THREE.Vector3();

  var lastPosition = new THREE.Vector3();

  var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };
  var state = STATE.NONE;


  var changeEvent = { type: 'change' };


  this.rotateLeft = function ( angle ) {

    if ( angle === undefined ) {

      angle = getAutoRotationAngle();

    }

    thetaDelta -= angle;

  };

  this.rotateUp = function ( angle ) {

    if ( angle === undefined ) {

      angle = getAutoRotationAngle();

    }

    phiDelta -= angle;

  };

  
  this.panLeft = function ( distance ) {

    var panOffset = new THREE.Vector3();
    var te = this.object.matrix.elements;

    panOffset.set( te[0], te[1], te[2] );
    panOffset.multiplyScalar(-distance);

    pan.add( panOffset );

  };

  this.panUp = function ( distance ) {

    var panOffset = new THREE.Vector3();
    var te = this.object.matrix.elements;
  
    panOffset.set( te[4], te[5], te[6] );
    panOffset.multiplyScalar(distance);

    pan.add( panOffset );
  };


  this.pan = function ( delta ) {

    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

    if ( scope.object.fov !== undefined ) {


      var position = scope.object.position;
      var offset = position.clone().sub( scope.target );
      var targetDistance = offset.length();

      
      targetDistance *= Math.tan( (scope.object.fov/2) * Math.PI / 180.0 );
      
      scope.panLeft( 2 * delta.x * targetDistance / element.clientHeight );
      scope.panUp( 2 * delta.y * targetDistance / element.clientHeight );

    } else if ( scope.object.top !== undefined ) {

 
      scope.panLeft( delta.x * (scope.object.right - scope.object.left) / element.clientWidth );
      scope.panUp( delta.y * (scope.object.top - scope.object.bottom) / element.clientHeight );

    } else {

      
      console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

    }

  };

  this.dollyIn = function ( dollyScale ) {

    if ( dollyScale === undefined ) {

      dollyScale = getZoomScale();

    }

    scale /= dollyScale;

  };

  this.dollyOut = function ( dollyScale ) {

    if ( dollyScale === undefined ) {

      dollyScale = getZoomScale();

    }

    scale *= dollyScale;

  };

  this.update = function () {

    var position = this.object.position;
    var offset = position.clone().sub( this.target );


    var theta = Math.atan2( offset.x, offset.z );

   

    var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

    if ( this.autoRotate ) {

      this.rotateLeft( getAutoRotationAngle() );

    }

    theta += thetaDelta;
    phi += phiDelta;

  
    phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

   
    phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

    var radius = offset.length() * scale;

 
    radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );

   
    this.target.add( pan );

    offset.x = radius * Math.sin( phi ) * Math.sin( theta );
    offset.y = radius * Math.cos( phi );
    offset.z = radius * Math.sin( phi ) * Math.cos( theta );

    position.copy( this.target ).add( offset );

    this.object.lookAt( this.target );

    thetaDelta = 0;
    phiDelta = 0;
    scale = 1;
    pan.set(0,0,0);

    if ( lastPosition.distanceTo( this.object.position ) > 0 ) {

      this.dispatchEvent( changeEvent );

      lastPosition.copy( this.object.position );

    }

  };


  function getAutoRotationAngle() {

    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

  }

  function getZoomScale() {

    return Math.pow( 0.95, scope.zoomSpeed );

  }

  function onMouseDown( event ) {

    if ( scope.enabled === false ) { return; }
    event.preventDefault();

    if ( event.button === 0 ) {
      if ( scope.noRotate === true ) { return; }

      state = STATE.ROTATE;

      rotateStart.set( event.clientX, event.clientY );

    } else if ( event.button === 1 ) {
      if ( scope.noZoom === true ) { return; }

      state = STATE.DOLLY;

      dollyStart.set( event.clientX, event.clientY );

    } else if ( event.button === 2 ) {
      if ( scope.noPan === true ) { return; }

      state = STATE.PAN;

      panStart.set( event.clientX, event.clientY );

    }


    scope.domElement.addEventListener( 'mousemove', onMouseMove, false );
    scope.domElement.addEventListener( 'mouseup', onMouseUp, false );

  }

  function onMouseMove( event ) {

    if ( scope.enabled === false ) return;

    event.preventDefault();

    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

    if ( state === STATE.ROTATE ) {

      if ( scope.noRotate === true ) return;

      rotateEnd.set( event.clientX, event.clientY );
      rotateDelta.subVectors( rotateEnd, rotateStart );

      scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
   
      scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

      rotateStart.copy( rotateEnd );

    } else if ( state === STATE.DOLLY ) {

      if ( scope.noZoom === true ) return;

      dollyEnd.set( event.clientX, event.clientY );
      dollyDelta.subVectors( dollyEnd, dollyStart );

      if ( dollyDelta.y > 0 ) {

        scope.dollyIn();

      } else {

        scope.dollyOut();

      }

      dollyStart.copy( dollyEnd );

    } else if ( state === STATE.PAN ) {

      if ( scope.noPan === true ) return;

      panEnd.set( event.clientX, event.clientY );
      panDelta.subVectors( panEnd, panStart );

      scope.pan( panDelta );

      panStart.copy( panEnd );

    }

  
    scope.update();

  }

  function onMouseUp( /* event */ ) {

    if ( scope.enabled === false ) return;


    scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );
    scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );

    state = STATE.NONE;

  }

  function onMouseWheel( event ) {

    if ( scope.enabled === false || scope.noZoom === true ) return;

    var delta = 0;

    if ( event.wheelDelta ) { 

      delta = event.wheelDelta;

    } else if ( event.detail ) { 
      delta = - event.detail;

    }

    if ( delta > 0 ) {

      scope.dollyOut();

    } else {

      scope.dollyIn();

    }

  }

  function onKeyDown( event ) {

    if ( scope.enabled === false ) { return; }
    if ( scope.noKeys === true ) { return; }
    if ( scope.noPan === true ) { return; }

    var needUpdate = false;

    switch ( event.keyCode ) {

      case scope.keys.UP:
        scope.pan( new THREE.Vector2( 0, scope.keyPanSpeed ) );
        needUpdate = true;
        break;
      case scope.keys.BOTTOM:
        scope.pan( new THREE.Vector2( 0, -scope.keyPanSpeed ) );
        needUpdate = true;
        break;
      case scope.keys.LEFT:
        scope.pan( new THREE.Vector2( scope.keyPanSpeed, 0 ) );
        needUpdate = true;
        break;
      case scope.keys.RIGHT:
        scope.pan( new THREE.Vector2( -scope.keyPanSpeed, 0 ) );
        needUpdate = true;
        break;
    }

    if ( needUpdate ) {

      scope.update();

    }

  }

  function touchstart( event ) {

    if ( scope.enabled === false ) { return; }

    switch ( event.touches.length ) {

      case 1:
        if ( scope.noRotate === true ) { return; }

        state = STATE.TOUCH_ROTATE;

        rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
        break;

      case 2: 
        if ( scope.noZoom === true ) { return; }

        state = STATE.TOUCH_DOLLY;

        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
        var distance = Math.sqrt( dx * dx + dy * dy );
        dollyStart.set( 0, distance );
        break;

      case 3: 
        if ( scope.noPan === true ) { return; }

        state = STATE.TOUCH_PAN;

        panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
        break;

      default:
        state = STATE.NONE;

    }
  }

  function touchmove( event ) {

    if ( scope.enabled === false ) { return; }

    event.preventDefault();
    event.stopPropagation();

    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

    switch ( event.touches.length ) {

      case 1: 
        if ( scope.noRotate === true ) { return; }
        if ( state !== STATE.TOUCH_ROTATE ) { return; }

        rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
        rotateDelta.subVectors( rotateEnd, rotateStart );

        
        scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
        
        scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

        rotateStart.copy( rotateEnd );
        break;

      case 2: 
        if ( scope.noZoom === true ) { return; }
        if ( state !== STATE.TOUCH_DOLLY ) { return; }

        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
        var distance = Math.sqrt( dx * dx + dy * dy );

        dollyEnd.set( 0, distance );
        dollyDelta.subVectors( dollyEnd, dollyStart );

        if ( dollyDelta.y > 0 ) {

          scope.dollyOut();

        } else {

          scope.dollyIn();

        }

        dollyStart.copy( dollyEnd );
        break;

      case 3: 
        if ( scope.noPan === true ) { return; }
        if ( state !== STATE.TOUCH_PAN ) { return; }

        panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
        panDelta.subVectors( panEnd, panStart );

        scope.pan( panDelta );

        panStart.copy( panEnd );
        break;

      default:
        state = STATE.NONE;

    }

  }

  function touchend( /* event */ ) {

    if ( scope.enabled === false ) { return; }

    state = STATE.NONE;
  }

  this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
  this.domElement.addEventListener( 'mousedown', onMouseDown, false );
  this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
  this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); 
  this.domElement.addEventListener( 'keydown', onKeyDown, false );

  this.domElement.addEventListener( 'touchstart', touchstart, false );
  this.domElement.addEventListener( 'touchend', touchend, false );
  this.domElement.addEventListener( 'touchmove', touchmove, false );

};

THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );

var plot3d = function(arrX, arrY,arrZ,config) {

  if (typeof config === 'undefined') config = {};

  var arrSort = function(arr){
    var newArr = arr.slice().sort(function(a,b){
      return a-b;
    });
    return newArr;
  };

  var xMax = arrSort(arrX)[arrX.length - 1];
  var xMin = arrSort(arrX)[0];
  var yMax = arrSort(arrY)[arrY.length - 1];
  var yMin = arrSort(arrY)[0];
  var zMax = arrSort(arrZ)[arrZ.length - 1];
  var zMin = arrSort(arrZ)[0];

  if (typeof config.size !== 'undefined'){
    var sizeMax = arrSort(config.size)[arrX.length - 1];
    var sizeMin = arrSort(config.size)[0];
  }

  var scene = new THREE.Scene();

  var light = new THREE.AmbientLight( 0x333333 );
  scene.add( light );

  var spotLight = new THREE.SpotLight( 0xffffff );
  spotLight.position.set( 100, 1000, 100 );
  spotLight.castShadow = true;
  spotLight.shadowMapWidth = 1024;
  spotLight.shadowMapHeight = 1024;
  spotLight.shadowCameraNear = 500;
  spotLight.shadowCameraFar = 4000;
  spotLight.shadowCameraFov = 30;
  scene.add( spotLight );

  var camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
  camera.position.x = 1.75 * Math.max(xMax, -xMin);
  camera.position.y = 1.75 * Math.max(yMax, -yMin);
  camera.position.z = 1.75 * Math.max(zMax, -zMin);

  var renderer = new THREE.WebGLRenderer();
  renderer.setClearColor(0xffffff);
  renderer.setSize( window.innerWidth, window.innerHeight );


  if (typeof config.elementID === 'undefined'){
    document.body.appendChild(renderer.domElement);
  }
  else{
    document.getElementById(config.elementID).appendChild(renderer.domElement);
  }

  renderer.domElement.style.width = (typeof config.width === 'undefined') ? '500px' : String(config.width)+'px';
  renderer.domElement.style.height = (typeof config.height === 'undefined') ? '500px' : String(config.height)+'px';


  controls = new THREE.OrbitControls( camera, renderer.domElement );
  controls.addEventListener( 'change', render );

  function animate(){
    requestAnimationFrame(animate);
    render();
    controls.update();
  }
  animate();


  function getColorObj(color){
    if (typeof color === 'undefined'){
      var colorObj = (typeof config.size === 'undefined') ? {color:0x000000} : {color:0x999999};
    }
    else{
      var colorObj = { color: parseInt('0x'+color) };
    }
    return colorObj;
  }

  function point(a,b,c,size,color){
    var geometry = new THREE.SphereGeometry(size,15,15);
    var material = new THREE.MeshLambertMaterial(getColorObj(color));
    var sphere = new THREE.Mesh(geometry, material);
    sphere.overdraw = true;
    sphere.position.x = a;
    sphere.position.y = b;
    sphere.position.z = c;
    return sphere;
  }


  var baseSize = Math.pow((xMax - xMin) * (yMax - yMin) * (zMax - zMin),1/3)/100;
  for (var i=0; i<arrX.length;i++){
    if (typeof config.size !== 'undefined'){
      var size = baseSize + baseSize*8*((config.size[i] - sizeMin)/(sizeMax - sizeMin));
    }
    else{
      var size = baseSize;
    }
    if (typeof config.color !== 'undefined'){
      var color = config.color[i];
    }
    else{
      var color = undefined;
    }
    scene.add(point(arrX[i],arrY[i],arrZ[i],size,color));
  }


  var matPos = new THREE.LineBasicMaterial({
    color: 0x000000
  });

   var matNeg = new THREE.LineBasicMaterial({
    color: 0x999999
  });

  var liner = function(x,y,z,material){
    var geometry = new THREE.Geometry();
    geometry.vertices.push(new THREE.Vector3(0, 0, 0));
    geometry.vertices.push(new THREE.Vector3(x, y, z));

    var line = new THREE.Line(geometry, material);
    return line;
  };

  if(xMax > 0) scene.add(liner(xMax,0,0,matPos));
  if(yMax > 0) scene.add(liner(0,yMax,0,matPos));
  if(zMax > 0) scene.add(liner(0,0,zMax,matPos));

  if(xMin < 0) scene.add(liner(xMin,0,0,matNeg));
  if(yMin < 0) scene.add(liner(0,yMin,0,matNeg));
  if(zMin < 0) scene.add(liner(0,0,zMin,matNeg));


  function axisLabel(text,posObj){
    var params = {
      font:'helvetiker',
      height:baseSize,
      size:baseSize*3,
      weight:'normal',
      style:'normal',
    };
    var labelGeo = new THREE.TextGeometry(text,params);
    setTimeout(function(){
      word.position.x = (posObj.x < 0) ? posObj.x - labelGeo.boundingSphere.radius*2: posObj.x;
      word.position.y = (posObj.y < 0) ? posObj.y - labelGeo.boundingSphere.radius/3: posObj.y;
      word.position.z = posObj.z;
    },100);
    var wrap = new THREE.MeshLambertMaterial({color:0x000000});
    var word = new THREE.Mesh(labelGeo,wrap);
    scene.add(word);
  }

  function rounder(num){
    return Math.round(num*100)/100;
  }
  var xLab = (typeof config.xLab === 'undefined') ? 'X = '+rounder(xMax) : config.xLab+' = '+rounder(xMax);
  var yLab = (typeof config.yLab === 'undefined') ? 'Y = '+rounder(yMax) : config.yLab+' = '+rounder(yMax);
  var zLab = (typeof config.zLab === 'undefined') ? 'Z = '+rounder(zMax) : config.zLab+' = '+rounder(zMax);

  var xLabMin = (typeof config.xLab === 'undefined') ? 'X = '+rounder(xMin) : config.xLab+' = '+rounder(xMin);
  var yLabMin = (typeof config.yLab === 'undefined') ? 'Y = '+rounder(yMin) : config.yLab+' = '+rounder(yMin);
  var zLabMin = (typeof config.zLab === 'undefined') ? 'Z = '+rounder(zMin) : config.zLab+' = '+rounder(zMin);

  if(xMax > 0) axisLabel(xLab, {x:xMax,y:0,z:0});
  if(yMax > 0) axisLabel(yLab, {x:0,y:yMax,z:0});
  if(zMax > 0) axisLabel(zLab, {x:0,y:0,z:zMax});
  if(xMin < 0) axisLabel(xLabMin, {x:xMin,y:0,z:0});
  if(yMin < 0) axisLabel(yLabMin, {x:0,y:yMin,z:0});
  if(zMin < 0) axisLabel(zLabMin, {x:0,y:0,z:zMin});

  function render(){
    renderer.render(scene,camera);
  }
  render();

  return renderer.domElement;
};


var Cows= [234,456,345,967,567,34,5234,21,3547,67,967,856,745,634,523,523,44,6658,67,976,856,74,56]; 
var Goats= [234,457,678,435,678,45,568,345,234,25,6,68,436,234,436,568,9,45,56,754,465,678,456]; 
var Centaurs= [45,345,75,656,345,346,5457,678,567,5467,456,657,769,56,567,3456,457,568,769,547,436,7,756]; 
var config = {xLab: 'Cows', yLab: 'Goats', zLab: 'Centaurs', };
plot3d(Cows,Goats,Centaurs,config);</script></html>